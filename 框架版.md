## 一、准备篇

1. 简历筛选规则![image-20240120143428849](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120143428849.png)
2. 简历注意事项![image-20240120143701861](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120143701861.png)![image-20240120144013809](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120144013809.png)![image-20240120144152693](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120144152693.png)**一定要列举出具体的点，引导面试官**![image-20240120144335097](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120144335097.png)![image-20240120144603447](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120144603447.png)
3. 合适的练手项目![image-20240120145555002](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120145555002.png)
4. Java面试过程![image-20240120150333850](%E9%BB%91%E9%A9%AC%E7%89%88.assets/image-20240120150333850.png)

----------

## 二、Redis

1. ![image-20240123144343594](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123144343594.png)
2. 缓存-缓存穿透![image-20240123144722619](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123144722619.png)![image-20240123144818451](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123144818451.png)![image-20240123144945169](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123144945169.png)![image-20240123145059160](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123145059160.png)5%的误判率即可![image-20240123145145867](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123145145867.png)![image-20240123145235814](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123145235814.png)
3. 缓存-缓存击穿![image-20240123145415911](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123145415911.png)![image-20240123150257288](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123150257288.png)逻辑过期就是不注重一致性，注重可用性，先返回了。在数据里有个逻辑字段(类似数据库逻辑删除一样)，这个字段就是逻辑上的过期时间，如果过期，那么先把旧数据返回(并不会删除)，然后并行查询数据库缓存数据，写入缓存并重置过期时间![image-20240123150539108](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123150539108.png)
4. 缓存-缓存雪崩![image-20240123152056150](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123152056150.png)![image-20240123152201408](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123152201408.png)
5. 缓存-双写一致性![image-20240123152507109](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123152507109.png)![image-20240123152801248](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123152801248.png)谁先谁后都会出问题。为什么要删两次？以为有脏数据；为什么要延迟删除？因为mysql从节点要从主节点同步完成

![image-20240123153322328](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123153322328.png)这样是强一致，低性能![image-20240123153458675](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123153458675.png)



6. 缓存-持久化![image-20240123154227250](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123154227250.png)![image-20240123154858030](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123154858030.png)![image-20240123154940318](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123154940318.png)![image-20240123155109452](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123155109452.png)![image-20240123155243134](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123155243134.png)![image-20240123155424269](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123155424269.png)
7. 缓存-数据过期策略![image-20240123155619024](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123155619024.png)![image-20240123155706121](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123155706121.png)![image-20240123155952392](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123155952392.png)![image-20240123160035160](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123160035160.png)
8. 缓存-数据淘汰策略![image-20240123160343612](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123160343612.png)![image-20240123160527456](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123160527456.png)![image-20240123160557163](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123160557163.png)![image-20240123160634655](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123160634655.png)
9. 分布式锁-使用场景![image-20240123160828351](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123160828351.png)![image-20240123161030086](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123161030086.png)![image-20240123161139440](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123161139440.png)![image-20240123161203111](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123161203111.png)![image-20240123161314962](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123161314962.png)
10. 分布式锁-实现原理![image-20240123161706616](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123161706616.png)![image-20240123162027265](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123162027265.png)![image-20240123162210111](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123162210111.png)![image-20240123162523408](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123162523408.png)同一个线程的才可以重入![image-20240123162707122](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123162707122.png)两个线程持有一把锁了，有红锁![image-20240123162803903](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123162803903.png)![image-20240123162953859](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123162953859.png)
11. 集群方案-主从复制![image-20240123190246270](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123190246270.png)因为redis读多写少，所以从节点主读![image-20240123191025989](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123191025989.png)![image-20240123191143783](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123191143783.png)![image-20240123191326490](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123191326490.png)
12. 集群方案-哨兵模式![image-20240123191723838](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123191723838.png)![image-20240123191926105](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123191926105.png)![image-20240123192120807](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123192120807.png)脑裂就是因为网络原因暂时联系不上主节点，但是哨兵从从节点中选出了一个当做主节点![image-20240123192545977](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123192545977.png)
13. 集群-分片集群![image-20240123192851849](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123192851849.png)![image-20240123193035768](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123193035768.png)![image-20240123193200561](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123193200561.png)
14. redis是单线程的，为什么还那么快？![image-20240123193601120](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123193601120.png)因为用户态跟内核态有缓冲区，就导致特别慢![image-20240123193932905](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123193932905.png)![image-20240123194105702](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123194105702.png)![image-20240123194246623](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123194246623.png)![image-20240123194510576](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123194510576.png)![image-20240123194702573](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123194702573.png)![image-20240123194952972](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123194952972.png)![image-20240123195130722](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123195130722.png)



## 三、MySQL

1. ![image-20240123195553217](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123195553217.png)
2. 优化-如何定位慢查询![image-20240123195806035](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123195806035.png)![image-20240123195919746](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123195919746.png)![image-20240123200031510](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123200031510.png)![image-20240123200114114](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123200114114.png)
3. 优化-SQL执行的很慢，怎么分析？![image-20240124150720987](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124150720987.png)![image-20240124150924771](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124150924771.png)![image-20240124151129269](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124151129269.png)![image-20240124151242062](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124151242062.png)
4. 优化-索引以及底层![image-20240124151608882](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124151608882.png)![image-20240124151758916](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124151758916.png)红黑树在数据量很大时，会特别深![image-20240124151938008](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124151938008.png)![image-20240124152225336](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124152225336.png)![image-20240124152329020](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124152329020.png)
5. 聚簇索引与非聚簇![image-20240124152644946](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124152644946.png)![image-20240124152758718](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124152758718.png)![image-20240124152930310](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124152930310.png)![image-20240124153031325](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124153031325.png)
6. 优化-覆盖索引、最大分页优化![image-20240124153453946](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124153453946.png)![image-20240124153648326](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124153648326.png)![image-20240124153745788](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124153745788.png)所以为什么避免使用**select ***![image-20240124153911264](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124153911264.png)![image-20240124154039317](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124154039317.png)![image-20240124154102515](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124154102515.png)
7. 优化-索引创建原则![image-20240124154634653](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124154634653.png)![image-20240124154715995](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124154715995.png)
8. 优化-什么时候索引会失效![image-20240124155055735](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155055735.png)![image-20240124155227483](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155227483.png)![image-20240124155426296](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155426296.png)![image-20240124155511554](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155511554.png)![image-20240124155717140](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155717140.png)![image-20240124155802354](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155802354.png)![image-20240124155843787](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155843787.png)
9. 优化-谈一谈优化SQL的经验![image-20240124160032772](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124160032772.png)![image-20240124160429564](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124160429564.png)![image-20240124160529827](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124160529827.png)![image-20240124160716643](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124160716643.png)
10. 事务-特性![image-20240124160927608](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124160927608.png)![image-20240124161050514](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161050514.png)![image-20240124161117294](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161117294.png)
11. 事务-并发事务、隔离级别![image-20240124161301678](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161301678.png)![image-20240124161545155](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161545155.png)![image-20240124161657346](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161657346.png)叉叉是解决了的意思![image-20240124161835525](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161835525.png)红字是不能解决的问题
12. 事务-undo log和redo log![image-20240124163959212](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124163959212.png)![image-20240124164158859](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164158859.png)![image-20240124164248825](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164248825.png)![image-20240124164315754](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164315754.png)
13. 事务-解释MVCC![image-20240124164454565](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164454565.png)![image-20240124164640810](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164640810.png)![image-20240124164818487](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164818487.png)![image-20240124164912850](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164912850.png)![image-20240124165150309](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124165150309.png)![image-20240124165405925](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124165405925.png)![image-20240124165506570](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124165506570.png)![image-20240124165652466](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124165652466.png)![image-20240124170005240](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170005240.png)![image-20240124170055345](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170055345.png)![image-20240124170238019](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170238019.png)、
14. 主从同步原理![image-20240124170441794](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170441794.png)![image-20240124170619700](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170619700.png)![image-20240124170655353](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170655353.png)
15. 分库分表![image-20240125150300806](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125150300806.png)![image-20240125150554729](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125150554729.png)![image-20240125150926086](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125150926086.png)![image-20240125151125880](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125151125880.png)![image-20240125151300598](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125151300598.png)![image-20240125151406289](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125151406289.png)![image-20240125151548045](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125151548045.png)![image-20240125151835996](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125151835996.png)

## 四、框架篇

1. spring-单例bean是线程安全的吗![image-20240125152614027](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125152614027.png)![image-20240125152800080](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125152800080.png)就好像成员变量是...，而对象是引用![image-20240125152909463](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125152909463.png)
2. spring-aop相关![image-20240125153106080](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125153106080.png)![image-20240125153554000](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125153554000.png)![image-20240125153700896](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125153700896.png)![image-20240125154235065](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125154235065.png)
3. spring-事务失效![image-20240125154323760](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125154323760.png)![image-20240125154740849](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125154740849.png)![image-20240125154904879](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125154904879.png)![image-20240125155055800](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125155055800.png)![image-20240125155134153](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125155134153.png)
4. spring-bean的生命周期![image-20240125155806912](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125155806912.png)![image-20240125160102659](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125160102659.png)![image-20240125160405013](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125160405013.png)![image-20240125161241238](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125161241238.png)
5. spring-循环引用![image-20240125161342762](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125161342762.png)![image-20240125161514214](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125161514214.png)![image-20240125161630812](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125161630812.png)![image-20240125161704240](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125161704240.png)![image-20240125161837052](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125161837052.png)目前已经能解决绝大多数的问题了，但如果一个对象是增强的，即代理对象，那二级就不行了![image-20240125162251880](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125162251880.png)![image-20240125162356407](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125162356407.png)![image-20240125162626870](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125162626870.png)![image-20240125162652104](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125162652104.png)
6. springmvc-执行流程![image-20240125163308408](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125163308408.png)![image-20240125164220055](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125164220055.png)![image-20240125164546320](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125164546320.png)![image-20240125164715544](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125164715544.png)![image-20240125164756601](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125164756601.png)
7. Springboot自动装配原理![image-20240125165255450](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125165255450.png)![image-20240126133309256](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126133309256.png)![image-20240126133442576](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126133442576.png)
8. spring框架常见注解![image-20240126133706116](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126133706116.png)![image-20240126133826154](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126133826154.png)![image-20240126133850754](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126133850754.png)
9. mybatis-执行流程![image-20240126134005731](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126134005731.png)![image-20240126134455575](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126134455575.png)![image-20240126134542822](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126134542822.png)
10. mybatis-延迟加载以及原理![image-20240126135616875](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126135616875.png)![image-20240126135738292](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126135738292.png)![image-20240126135901992](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126135901992.png)
11. mybatis-一级、二级缓存![image-20240126140041575](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126140041575.png)![image-20240126140251475](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126140251475.png)![image-20240126141217707](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126141217707.png)![image-20240126141521320](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126141521320.png)![image-20240126141623061](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126141623061.png)

## 五、微服务

1. ![image-20240126142444493](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126142444493.png)
2. springcloud常见组件![image-20240126142902071](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126142902071.png)![image-20240126142928766](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126142928766.png)
3. springcloud-注册中心eureka、nacos![image-20240126143116141](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126143116141.png)![image-20240126143413852](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126143413852.png)![image-20240126143533753](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126143533753.png)![image-20240126143736256](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126143736256.png)![image-20240126143831822](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126143831822.png)AP是高可用，CP是强一致
4. springcloud-ribbon负载均衡![image-20240126184331383](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126184331383.png)![image-20240126184508333](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126184508333.png)![image-20240126184809547](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126184809547.png)![image-20240126184934059](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126184934059.png)![image-20240126185052207](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126185052207.png)
5. springcloud-服务雪崩、熔断降级![image-20240126185309628](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126185309628.png)![image-20240126185405255](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126185405255.png)![image-20240126185514842](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126185514842.png)![image-20240126185719115](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126185719115.png)![image-20240126185815541](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126185815541.png)降级是针对某个服务的某个接口，熔断是对整个服务的所有接口都拒绝![image-20240126190035203](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126190035203.png)
6. springcloud-监控skywalking![image-20240126190427997](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126190427997.png)![image-20240126190543858](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126190543858.png)![image-20240126190900243](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126190900243.png)通过红圈处分析是哪些导致慢速![image-20240126191119129](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126191119129.png)
7. 业务问题-微服务限流（漏桶算法、令牌桶算法![image-20240126191218042](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126191218042.png)![image-20240126191556632](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126191556632.png)![image-20240126191844799](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126191844799.png)![image-20240126192053593](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126192053593.png)![image-20240126192733583](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126192733583.png)![image-20240126192912691](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126192912691.png)漏桶是按照固定速率处理请求，而令牌桶是一定速率生成令牌，按照令牌数量处理请求，比如一秒可以生成五个令牌。那么一秒内五个请求内的都可以被处理，但是多余的就不行了
8. 分布式系统理论-CAP和BASE![image-20240126193538754](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126193538754.png)![image-20240126193622609](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126193622609.png)![image-20240126193704895](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126193704895.png)![image-20240126193739597](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126193739597.png)![image-20240126194007046](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126194007046.png)![image-20240126194410652](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126194410652.png)![image-20240126194535835](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126194535835.png)
9. 业务问题-分布式事务解决方案![image-20240126195301501](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126195301501.png)![image-20240126195403134](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126195403134.png)![image-20240126195547112](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126195547112.png)![image-20240126195723920](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126195723920.png)![image-20240126195932364](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126195932364.png)![image-20240126200103775](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126200103775.png)![image-20240126200233281](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126200233281.png)
10. 业务问题-分布式服务的接口幂等性![image-20240126200814680](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126200814680.png)![image-20240126201018874](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126201018874.png)![image-20240126201230770](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126201230770.png)![image-20240126201332391](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126201332391.png)![image-20240126201426128](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126201426128.png)
11. 业务问题-分布式任务调度![image-20240126202710693](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126202710693.png)![image-20240126202917218](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126202917218.png)![image-20240126203104140](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126203104140.png)![image-20240126203244577](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126203244577.png)![image-20240126203343102](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240126203343102.png)



## 六、消息中间件

1. ![image-20240128161325649](./框架版.assets/image-20240128161325649.png)
2. RabbitMQ-如何保证消息不丢失![image-20240128161649434](./框架版.assets/image-20240128161649434.png)![image-20240128161811067](./框架版.assets/image-20240128161811067.png)![image-20240128161907304](./框架版.assets/image-20240128161907304.png)![image-20240128162053325](./框架版.assets/image-20240128162053325.png)![image-20240128162239350](./框架版.assets/image-20240128162239350.png)
3. RabbitMQ-重复消费的问题![image-20240128162915404](./框架版.assets/image-20240128162915404.png)
4. RabbitMQ-死信交换机（延迟队列）![image-20240128163221916](./框架版.assets/image-20240128163456223.png)![image-20240128163648496](./框架版.assets/image-20240128163648496.png)以谁短为准![image-20240128163744397](./框架版.assets/image-20240128163744397.png)![image-20240128163819163](./框架版.assets/image-20240128163819163.png)![image-20240128163934089](./框架版.assets/image-20240128163934089.png)
5. RabbitMQ-如何解决消息堆积![image-20240128164213016](./框架版.assets/image-20240128164213016.png)![image-20240128164319226](./框架版.assets/image-20240128164319226.png)![image-20240128164420825](./框架版.assets/image-20240128164420825.png)
6. RabbitMQ-高可用机制![image-20240128164510138](./框架版.assets/image-20240128164510138.png)![image-20240128164637925](./框架版.assets/image-20240128164637925.png)![image-20240128164809936](./框架版.assets/image-20240128164809936.png)![image-20240128164838494](./框架版.assets/image-20240128164838494.png)![image-20240128164937188](./框架版.assets/image-20240128164937188.png)
7. Kafka-保证消息不丢失![image-20240128171104088](./框架版.assets/image-20240128171104088.png)![image-20240128171236980](./框架版.assets/image-20240128171236980.png)![image-20240128171442451](./框架版.assets/image-20240128171442451.png)![image-20240128171540921](./框架版.assets/image-20240128171540921.png)![image-20240128171847289](./框架版.assets/image-20240128171847289.png)出现问题是因为固定时间段提交，改成手动提交就行![image-20240128172033267](./框架版.assets/image-20240128172033267.png)
8. Kafka-如何保证消费的顺序性![image-20240129150126115](./框架版.assets/image-20240129150126115.png)![image-20240129150308125](./框架版.assets/image-20240129150308125.png)![image-20240129150351618](./框架版.assets/image-20240129150351618.png)
9. Kafka-高可用机制![image-20240129150422444](./框架版.assets/image-20240129150422444.png)![image-20240129150458903](./框架版.assets/image-20240129150458903.png)![image-20240129150612441](./框架版.assets/image-20240129150612441.png)![image-20240129150720588](./框架版.assets/image-20240129150720588.png)![image-20240129150838598](./框架版.assets/image-20240129150838598.png)
10. Kafka-数据清理机制![image-20240129150916797](./框架版.assets/image-20240129150916797.png)![image-20240129151103934](./框架版.assets/image-20240129151103934.png)![image-20240129151156638](./框架版.assets/image-20240129151156638.png)![image-20240129151247313](./框架版.assets/image-20240129151247313.png)
11. Kafka-高性能设计![image-20240129151510414](./框架版.assets/image-20240129151510414.png)![image-20240129151726728](./框架版.assets/image-20240129151726728.png)这样需要拷贝很多次，效率低下，改进如下：![image-20240129151811354](./框架版.assets/image-20240129151811354.png)![image-20240129151902675](./框架版.assets/image-20240129151902675.png)



## 七、常见集合

1. ![image-20240130180453017](./框架版.assets/image-20240130180453017.png)
2. 算法复杂度分析![image-20240130180922642](./框架版.assets/image-20240130180922642.png)![image-20240130190354495](./框架版.assets/image-20240130190354495.png)![image-20240130190523733](./框架版.assets/image-20240130190523733.png)![image-20240130190633636](./框架版.assets/image-20240130190633636.png)![image-20240130190751796](./框架版.assets/image-20240130190751796.png)![image-20240130190944182](./框架版.assets/image-20240130190944182.png)![image-20240130191043477](./框架版.assets/image-20240130191043477.png)![image-20240130191345054](./框架版.assets/image-20240130191345054.png)![image-20240130191436978](./框架版.assets/image-20240130191436978.png)
3. ArrayList-数据结构-数组![image-20240130191602122](./框架版.assets/image-20240130191602122.png)![image-20240130191714258](./框架版.assets/image-20240130191714258.png)![image-20240130191854302](./框架版.assets/image-20240130191854302.png)![image-20240130192016360](./框架版.assets/image-20240130192016360.png)![image-20240130192140881](./框架版.assets/image-20240130192140881.png)![image-20240130192214903](./框架版.assets/image-20240130192214903.png)![image-20240130192313784](./框架版.assets/image-20240130192313784.png)![image-20240130192409729](./框架版.assets/image-20240130192409729.png)
4. ArrayList-源码分析![image-20240130192900096](./框架版.assets/image-20240130192900096.png)以JDK8为例![image-20240130193039441](./框架版.assets/image-20240130193039441.png)![image-20240130193239474](./框架版.assets/image-20240130193239474.png)![image-20240130193658714](./框架版.assets/image-20240130193658714.png)![image-20240130193858919](./框架版.assets/image-20240130193858919.png)![image-20240130194021846](./框架版.assets/image-20240130194021846.png)
5. ArrayList-底层实现原理![image-20240130194902142](./框架版.assets/image-20240130194902142.png)![image-20240130194950149](./框架版.assets/image-20240130194950149.png)只有真的添加数据的时候才会扩容
6. ArrayList-数组和List之间的相互转换![image-20240130195138889](./框架版.assets/image-20240130195138889.png)![image-20240130195448212](./框架版.assets/image-20240130195448212.png)
7. LinkedList-数据结构-链表![image-20240130200659291](./框架版.assets/image-20240130200659291.png)双向链表时间复杂度![image-20240130201033003](./框架版.assets/image-20240130201033003.png)![image-20240130201113745](./框架版.assets/image-20240130201113745.png)
8. ArrayList和Like的List的区别是什么![image-20240130201315432](./框架版.assets/image-20240130201315432.png)![image-20240130201411212](./框架版.assets/image-20240130201411212.png)
9. 数据结构-二叉树![image-20240130202602819](./框架版.assets/image-20240130202602819.png)![image-20240130202636180](./框架版.assets/image-20240130202636180.png)![image-20240130202747600](./框架版.assets/image-20240130202747600.png)![image-20240130202932177](./框架版.assets/image-20240130202932177.png)![image-20240130202954658](./框架版.assets/image-20240130202954658.png)![image-20240130203034296](./框架版.assets/image-20240130203034296.png)
10. 数据结构-红黑树![image-20240130203112483](./框架版.assets/image-20240130203112483.png)![image-20240130203302219](./框架版.assets/image-20240130203302219.png)![image-20240130203416802](./框架版.assets/image-20240130203416802.png)![image-20240130203431093](./框架版.assets/image-20240130203431093.png)
11. 数据结构-散列表![image-20240201193327726](./框架版.assets/image-20240201193327726.png)![image-20240201193420774](./框架版.assets/image-20240201193420774.png)![image-20240201193509957](./框架版.assets/image-20240201193509957.png)![image-20240201193626236](./框架版.assets/image-20240201193626236.png)![image-20240201193710364](./框架版.assets/image-20240201193710364.png)![image-20240201193757905](./框架版.assets/image-20240201193757905.png)![image-20240201193940574](./框架版.assets/image-20240201193940574.png)![image-20240201194041500](./框架版.assets/image-20240201194041500.png)![image-20240201194149434](./框架版.assets/image-20240201194149434.png)
12. HashMap-实现原理![image-20240201194735037](./框架版.assets/image-20240201194735037.png)![image-20240201194807008](./框架版.assets/image-20240201194807008.png)![image-20240201194845615](./框架版.assets/image-20240201194845615.png)
13. HashMap-put方法的流程![image-20240201195151942](./框架版.assets/image-20240201195151942.png)![image-20240201195242868](./框架版.assets/image-20240201195242868.png)![image-20240201195617869](./框架版.assets/image-20240201195617869.png)![image-20240201200042371](./框架版.assets/image-20240201200042371.png)hashmap是懒加载，只有用到的时候才会初始化![image-20240201200211786](./框架版.assets/image-20240201200211786.png)
14. HashMap-扩容机制![image-20240201201122192](./框架版.assets/image-20240201201122192.png)![image-20240201201607573](./框架版.assets/image-20240201201607573.png)
15. HashMap-源码分析![image-20240201203045810](./框架版.assets/image-20240201203045810.png)![image-20240201203055703](./框架版.assets/image-20240201203055703.png)![image-20240201203109227](./框架版.assets/image-20240201203109227.png)![image-20240201203140197](./框架版.assets/image-20240201203140197.png)
16. HashMap-寻址算法![image-20240201204138579](./框架版.assets/image-20240201204138579.png)![image-20240201204447027](./框架版.assets/image-20240201204447027.png)![image-20240201204536020](./框架版.assets/image-20240201204536020.png)
17. HashMap-1.7情况下多线程死循环的问题![image-20240201204746023](./框架版.assets/image-20240201204746023.png)![image-20240201204815454](./框架版.assets/image-20240201204815454.png)![image-20240201205018852](./框架版.assets/image-20240201205018852.png)因为1.7用的是头插法![image-20240201205128003](./框架版.assets/image-20240201205128003.png)



## 八、并发编程

1. ![image-20240201205243330](./框架版.assets/image-20240201205243330.png)
2. 线程基础-进程与线程的区别![image-20240202152629590](./框架版.assets/image-20240202152629590.png)![image-20240202152657001](./框架版.assets/image-20240202152657001.png)![image-20240202153034820](./框架版.assets/image-20240202153034820.png)
3. 线程基础-并行与并发的区别![image-20240202153229860](./框架版.assets/image-20240202153229860.png)![image-20240202153307701](./框架版.assets/image-20240202153307701.png)![image-20240202153355096](./框架版.assets/image-20240202153355096.png)![image-20240202153430049](./框架版.assets/image-20240202153430049.png)
4. 线程基础-创建线程的方式![image-20240202153536298](./框架版.assets/image-20240202153536298.png)![image-20240202153605375](./框架版.assets/image-20240202153605375.png)new了几个对象就创建了几个线程，start才是启动，而不是run![image-20240202153711152](./框架版.assets/image-20240202153711152.png)![image-20240202153917436](./框架版.assets/image-20240202153917436.png)![image-20240202154008460](./框架版.assets/image-20240202154008460.png)![image-20240202154156523](./框架版.assets/image-20240202154156523.png)run方法不能抛异常，但是call方法可以抛出![image-20240202154327221](./框架版.assets/image-20240202154327221.png)![image-20240202154502051](./框架版.assets/image-20240202154502051.png)直接调用run方法就是普通调用了![image-20240202154538219](./框架版.assets/image-20240202154538219.png)
5. 线程基础-线程包括哪些3状态，如何变化![image-20240202154640400](./框架版.assets/image-20240202154640400.png)![image-20240202155235227](./框架版.assets/image-20240202155235227.png)![image-20240202155401985](./框架版.assets/image-20240202155401985.png)
6. 线程基础-保证线程按照顺序执行![image-20240202155608226](./框架版.assets/image-20240202155608226.png)notify和notifyall的区别![image-20240202155733914](./框架版.assets/image-20240202155733914.png)
7. 线程基础-wait和sleep的异同点![image-20240202160036494](./框架版.assets/image-20240202160036494.png)
8. 线程基础-停止一个正在运行的线程![image-20240202161430560](./框架版.assets/image-20240202161430560.png)
9. 并发安全-synchronized底层原理![image-20240202183234406](./框架版.assets/image-20240202183234406.png)两个解锁是因为如果抛异常也要解锁，因此有两个，以防万一![image-20240202183505282](./框架版.assets/image-20240202183505282.png)在EntryList中并不是队列的形式，而是随机叫号。涉及到JVM都是内核态![image-20240202183742255](./框架版.assets/image-20240202183742255.png)![image-20240202183817926](./框架版.assets/image-20240202183817926.png)
10. 线程安全-synchronized地层原理进阶![image-20240202184502308](./框架版.assets/image-20240202184502308.png)![image-20240202184623370](./框架版.assets/image-20240202184623370.png)![image-20240202184802065](./框架版.assets/image-20240202184802065.png)![image-20240202184851347](./框架版.assets/image-20240202184851347.png)![image-20240202184943080](./框架版.assets/image-20240202184943080.png)锁重入了![image-20240202185222742](./框架版.assets/image-20240202185222742.png)![image-20240202185521257](./框架版.assets/image-20240202185521257.png)![image-20240202185610876](./框架版.assets/image-20240202185610876.png)![image-20240202185732158](./框架版.assets/image-20240202185732158.png)![image-20240202185851158](./框架版.assets/image-20240202185851158.png)
11. 线程安全-JMM-Java内存模型![image-20240202190147385](./框架版.assets/image-20240202190147385.png)![image-20240202190218801](./框架版.assets/image-20240202190218801.png)
12. 线程安全-CAS![image-20240202191021739](./框架版.assets/image-20240202191021739.png)工作内存中的数据会与主内存中的数据进行对比，如果二者一样才会去修改![image-20240202191359060](./框架版.assets/image-20240202191359060.png)![image-20240202191519906](./框架版.assets/image-20240202191519906.png)![image-20240202191550933](./框架版.assets/image-20240202191550933.png)![image-20240202191807468](./框架版.assets/image-20240202191807468.png)
13. 线程安全-volatile![image-20240202191909533](./框架版.assets/image-20240202191909533.png)![image-20240202192256759](./框架版.assets/image-20240202192256759.png)很像vue中的数据双向绑定，也就是框架是否“聪明”![image-20240202192515196](./框架版.assets/image-20240202192515196.png)
14. 线程安全-volatile禁止指令重排序![image-20240202192806458](./框架版.assets/image-20240202192806458.png)![image-20240202193840340](./框架版.assets/image-20240202193840340.png)![image-20240202194043500](./框架版.assets/image-20240202194043500.png)指令重排序是对cpu的优化![image-20240202194121884](./框架版.assets/image-20240202194121884-1706874082791-1.png)
15. 线程安全-AQS![image-20240203183446546](./框架版.assets/image-20240203183446546.png)![image-20240203183635394](./框架版.assets/image-20240203183635394.png)![image-20240203183738222](./框架版.assets/image-20240203183738222.png)![image-20240203183846871](./框架版.assets/image-20240203183846871.png)是否公平锁意味有没有“排队”![image-20240203183957815](./框架版.assets/image-20240203183957815.png)
16. 线程安全-ReentrantLock实现原理![image-20240203184206980](./框架版.assets/image-20240203184206980.png)![image-20240203184311731](./框架版.assets/image-20240203184311731.png)![image-20240203184428351](./框架版.assets/image-20240203184428351.png)![image-20240203184457812](./框架版.assets/image-20240203184457812.png)
17. 线程安全-synchronized和Lock有什么区别![image-20240203185349959](./框架版.assets/image-20240203185349959.png)
18. 线程安全-死锁产生条件![image-20240203185724251](./框架版.assets/image-20240203185724251.png)![image-20240203185936549](./框架版.assets/image-20240203185936549.png)![image-20240203190010327](./框架版.assets/image-20240203190010327.png)![image-20240203190212005](./框架版.assets/image-20240203190212005.png)![image-20240203190229098](./框架版.assets/image-20240203190229098.png)
19. 线程安全-ConcurrentHashMap![image-20240203190339984](./框架版.assets/image-20240203190339984.png)![image-20240203190410020](./框架版.assets/image-20240203190410020.png)![image-20240203190506852](./框架版.assets/image-20240203190506852.png)![image-20240203190614284](./框架版.assets/image-20240203190614284.png)![image-20240203190644127](./框架版.assets/image-20240203190644127.png)
20. 线程安全-保证多线程的执行安全![image-20240203190736019](./框架版.assets/image-20240203190736019.png)![image-20240203190823979](./框架版.assets/image-20240203190823979.png)![image-20240203190836171](./框架版.assets/image-20240203190836171.png)![image-20240203190931624](./框架版.assets/image-20240203190931624.png)![image-20240203191014659](./框架版.assets/image-20240203191014659.png)![image-20240203191037066](./框架版.assets/image-20240203191037066.png)
21. 线程池-核心参数-执行原理![image-20240203192104228](./框架版.assets/image-20240203192104228.png)![image-20240203192222412](./框架版.assets/image-20240203192222412.png)
22. 线程池-常见的阻塞队列![image-20240203193507467](./框架版.assets/image-20240203193507467.png)![image-20240203193704739](./框架版.assets/image-20240203193704739.png)
23. 线程池-确定核心线程数![image-20240203194039099](./框架版.assets/image-20240203194039099.png)N是cpu核数，并不是说计算密集型就一定需要更多的cpu核。因为如果分配很多的核，那么线程切换上下文是有成本的，反而会造成效率低下
24. 线程池-种类![image-20240203194922135](./框架版.assets/image-20240203194922135.png)![image-20240203195046587](./框架版.assets/image-20240203195046587.png)![image-20240203195841687](./框架版.assets/image-20240203195841687.png)![image-20240203200033428](./框架版.assets/image-20240203200033428.png)![image-20240203200058156](./框架版.assets/image-20240203200058156.png)
25. 线程池-不用Executors创建线程池![image-20240203200641430](./框架版.assets/image-20240203200641430.png)
26. 使用场景-CountDownLatch![image-20240203201435327](./框架版.assets/image-20240203201435327.png)![image-20240203201519921](./框架版.assets/image-20240203201519921.png)![image-20240203202319953](./框架版.assets/image-20240203202319953.png)
27. 使用场景-数据汇总![image-20240203202500161](./框架版.assets/image-20240203202500161.png)![image-20240203202931940](./框架版.assets/image-20240203202931940.png)
28. 使用场景-异步调用![image-20240203203022651](./框架版.assets/image-20240203203022651.png)![image-20240203203515765](./框架版.assets/image-20240203203515765.png)
29. 使用场景-控制某个方法并发访问线程数量![image-20240204163109153](./框架版.assets/image-20240204163109153.png)![image-20240204163346928](./框架版.assets/image-20240204163346928.png)![image-20240204163359631](./框架版.assets/image-20240204163359631.png)
30. 其他-对ThreadLocal的理解![image-20240204163506442](./框架版.assets/image-20240204163506442.png)![image-20240204163709195](./框架版.assets/image-20240204163709195.png)![image-20240204163849247](./框架版.assets/image-20240204163849247.png)![image-20240204163914980](./框架版.assets/image-20240204163914980.png)![image-20240204163956211](./框架版.assets/image-20240204163956211.png)![image-20240204164105042](./框架版.assets/image-20240204164105042.png)![image-20240204164157668](./框架版.assets/image-20240204164157668.png)![image-20240204164253822](./框架版.assets/image-20240204164253822.png)



## 九、JVM虚拟机

1. ![image-20240204164703004](./框架版.assets/image-20240204164703004.png)![image-20240204164809796](./框架版.assets/image-20240204164809796.png)![image-20240204164911266](./框架版.assets/image-20240204164911266.png)
2. JVM组成-程序计数器![image-20240204165107249](./框架版.assets/image-20240204165107249.png)![image-20240204165355060](./框架版.assets/image-20240204165355060.png)![image-20240204165412405](./框架版.assets/image-20240204165412405.png)
3. JVM组成-Java堆![image-20240204191659235](./框架版.assets/image-20240204191659235.png)![image-20240204191749692](./框架版.assets/image-20240204191749692.png)![image-20240204191830285](./框架版.assets/image-20240204191830285.png)
4. JVM组成-虚拟机栈![image-20240204192129470](./框架版.assets/image-20240204192129470.png)![image-20240204192218215](./框架版.assets/image-20240204192218215.png)![image-20240204192443662](./框架版.assets/image-20240204192443662.png)可以类似看做有没有“输入输出”，第二是有“输入”。第三是“输出”![image-20240204192750753](./框架版.assets/image-20240204192750753.png)![image-20240204192903027](./框架版.assets/image-20240204192903027.png)![image-20240204192937951](./框架版.assets/image-20240204192937951.png)
5. JVM组成-方法区![image-20240204193229415](./框架版.assets/image-20240204193229415.png)![image-20240204193858829](./框架版.assets/image-20240204193858829.png)![image-20240204193947106](./框架版.assets/image-20240204193947106.png)
6. JVM组成-直接内存![image-20240204194429498](./框架版.assets/image-20240204194429498.png)![image-20240204195243823](./框架版.assets/image-20240204195243823.png)![image-20240204195327589](./框架版.assets/image-20240204195327589.png)![image-20240204195349089](./框架版.assets/image-20240204195349089.png)
7. 类加载器-什么是类加载器![image-20240204195758451](./框架版.assets/image-20240204195758451.png)![image-20240204200128130](./框架版.assets/image-20240204200128130.png)![image-20240204200205100](./框架版.assets/image-20240204200205100.png)双亲委派模型![image-20240204200354955](./框架版.assets/image-20240204200354955.png)![image-20240204200443676](./框架版.assets/image-20240204200443676.png)![image-20240204200533559](./框架版.assets/image-20240204200533559.png)
8. 类加载器-类装载的执行过程![image-20240204201021741](./框架版.assets/image-20240204201021741.png)![image-20240204201147063](./框架版.assets/image-20240204201147063.png)![image-20240204201300243](./框架版.assets/image-20240204201300243.png)![image-20240204201426867](./框架版.assets/image-20240204201426867.png)![image-20240204201517896](./框架版.assets/image-20240204201517896.png)![image-20240204202630933](./框架版.assets/image-20240204202630933.png)![image-20240204202648559](./框架版.assets/image-20240204202648559.png)![image-20240204202720996](./框架版.assets/image-20240204202720996.png)
9. 垃圾回收-对象什么时候被垃圾器回收![image-20240204203548583](./框架版.assets/image-20240204203548583.png)![image-20240204203639952](./框架版.assets/image-20240204203639952.png)![image-20240204203757181](./框架版.assets/image-20240204203757181.png)![image-20240204204007384](./框架版.assets/image-20240204204007384.png)![image-20240204204106399](./框架版.assets/image-20240204204106399.png)![image-20240204204130470](./框架版.assets/image-20240204204130470.png)
10. 垃圾回收-JVM垃圾回收算法![image-20240204204214444](./框架版.assets/image-20240204204214444.png)![image-20240204204303304](./框架版.assets/image-20240204204303304.png)![image-20240204204352074](./框架版.assets/image-20240204204352074.png)![image-20240204204435870](./框架版.assets/image-20240204204435870.png)![image-20240204204539889](./框架版.assets/image-20240204204539889.png)
11. 垃圾回收-分代垃圾回收



126-134  高鹏

135-143  吕童

144-152  黄妍舒

153-161  韩冰清

162-170  王瑜若

171-179  冉芷萱

180-187  罗伟力



## 5

----------------

精简版

16. ![image-20240123191444867](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123191444867.png)
17. ![image-20240123192619156](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123192619156.png)
18. ![image-20240123193216951](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123193216951.png)
19. ![image-20240123195147351](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240123195147351.png)
20. ![image-20240124151302424](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124151302424.png)
21. ![image-20240124152349798](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124152349798.png)
22. ![image-20240124153058112](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124153058112.png)
23. ![image-20240124154131578](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124154131578.png)
24. ![image-20240124154738611](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124154738611.png)
25. ![image-20240124155901816](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124155901816.png)
26. ![image-20240124160736182](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124160736182.png)
27. ![image-20240124161133716](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161133716.png)
28. ![image-20240124161901972](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124161901972.png)
29. ![image-20240124164329885](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124164329885.png)
30. ![image-20240124170301160](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170301160.png)
31. ![image-20240124170714731](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240124170714731.png)
32. ![image-20240125152924727](%E6%A1%86%E6%9E%B6%E7%89%88.assets/image-20240125152924727.png)











## 6

16.  
16. test